{% extends "base.html" %}

{% block title %}SIMS Uploader · New Upload{% endblock %}

{% block content %}
  <section class="panel">
    <h2>Enqueue a new upload</h2>
    <p>
      Provide workbook details and optional limits to enqueue a new upload job.
    </p>
    <div id="form-errors" class="alert alert--error" role="alert" hidden></div>
    <form
      id="upload-form"
      class="form-grid"
      data-enqueue-url="{{ request.url_for('create_upload_job') }}"
      data-upload-url="{{ request.url_for('upload_workbook') }}"
      data-uploads-list-url="{{ request.url_for('render_uploads_list') }}"
    >
      <div class="field-group">
        <label for="workbook_file">Workbook file</label>
        <input type="file" id="workbook_file" name="workbook_file" />
        <p class="field-help">Choose a workbook to upload and stage automatically.</p>
      </div>

      <input type="hidden" id="workbook_path" name="workbook_path" autocomplete="off" />

      <div class="field-group">
        <label for="manual_workbook_path">Workbook path (manual entry)</label>
        <input
          type="text"
          id="manual_workbook_path"
          name="manual_workbook_path"
          autocomplete="off"
          placeholder="\\\path\to\workbook.xlsx"
        />
        <p class="field-help">Leave blank when uploading a file; provide a path to enqueue without uploading.</p>
        <p class="field-error" data-error-for="manual_workbook_path" hidden></p>
      </div>

      <div class="field-group">
        <label for="workbook_name">Workbook name</label>
        <input
          type="text"
          id="workbook_name"
          name="workbook_name"
          autocomplete="off"
          placeholder="Workbook display name"
        />
        <p class="field-error" data-error-for="workbook_name" hidden></p>
      </div>

      <div class="field-group">
        <label for="sheet">Sheet<span aria-hidden="true"> *</span></label>
        <input
          type="text"
          id="sheet"
          name="sheet"
          autocomplete="off"
          placeholder="Worksheet reference"
        />
        <p class="field-error" data-error-for="sheet" hidden></p>
      </div>

      <div class="field-group">
        <label for="worksheet_name">Worksheet name</label>
        <input
          type="text"
          id="worksheet_name"
          name="worksheet_name"
          autocomplete="off"
          placeholder="Optional worksheet name override"
        />
      </div>

      <div class="field-group">
        <label for="source_year">Source year<span aria-hidden="true"> *</span></label>
        <input
          type="text"
          id="source_year"
          name="source_year"
          autocomplete="off"
          placeholder="2024"
        />
        <p class="field-error" data-error-for="source_year" hidden></p>
      </div>

      <div class="field-group">
        <label for="workbook_type">Workbook type</label>
        <input
          type="text"
          id="workbook_type"
          name="workbook_type"
          value="default"
          autocomplete="off"
        />
      </div>

      <div class="field-group">
        <label for="batch_id">Batch ID</label>
        <input type="text" id="batch_id" name="batch_id" autocomplete="off" />
      </div>

      <div class="field-group">
        <label for="file_size">File size (bytes)</label>
        <input type="number" id="file_size" name="file_size" min="0" step="1" />
        <p class="field-error" data-error-for="file_size" hidden></p>
      </div>

      <div class="field-group">
        <label for="row_count">Row count</label>
        <input type="number" id="row_count" name="row_count" min="0" step="1" />
      </div>

      <div class="field-group">
        <label for="max_file_size">Max file size (bytes)</label>
        <input type="number" id="max_file_size" name="max_file_size" min="0" step="1" />
      </div>

      <div class="field-group">
        <label for="max_rows">Max rows</label>
        <input type="number" id="max_rows" name="max_rows" min="0" step="1" />
      </div>

      <input
        type="hidden"
        id="conflict_resolution"
        name="conflict_resolution"
        value="append"
      />

      <div id="overlap-panel" class="alert alert--warning" role="status" hidden>
        <p id="overlap-summary"></p>
        <div id="overlap-list" class="overlap-list"></div>
        <div class="button-row">
          <button type="button" class="secondary-button" data-resolution="append">
            Append anyway
          </button>
          <button type="button" class="secondary-button" data-resolution="replace">
            Replace overlaps
          </button>
          <button type="button" class="secondary-button" data-resolution="skip">
            Skip upload
          </button>
        </div>
      </div>

      <div class="form-actions">
        <button type="submit" class="primary-button">Submit upload job</button>
        <span id="form-status" role="status" aria-live="polite"></span>
      </div>
    </form>
  </section>
{% endblock %}

{% block scripts %}
  <script>
    (function () {
      const form = document.getElementById('upload-form');
      if (!form) {
        return;
      }

      const errorBox = document.getElementById('form-errors');
      const statusBox = document.getElementById('form-status');
      const numberFields = new Set(['file_size', 'row_count', 'max_file_size', 'max_rows']);
      const enqueueUrl = form.dataset.enqueueUrl;
      const uploadUrl = form.dataset.uploadUrl;
      const uploadsListUrl = form.dataset.uploadsListUrl;
      const workbookFileInput = document.getElementById('workbook_file');
      const workbookPathField = document.getElementById('workbook_path');
      const manualPathField = document.getElementById('manual_workbook_path');
      const workbookNameField = document.getElementById('workbook_name');
      const fileSizeField = document.getElementById('file_size');
      const sheetField = document.getElementById('sheet');
      const sourceYearField = document.getElementById('source_year');
      const workbookTypeField = document.getElementById('workbook_type');
      const conflictResolutionField = document.getElementById('conflict_resolution');
      const overlapPanel = document.getElementById('overlap-panel');
      const overlapSummary = document.getElementById('overlap-summary');
      const overlapList = document.getElementById('overlap-list');
      const overlapButtons = document.querySelectorAll('[data-resolution]');
      let lastPayload = null;

      function setDefaultValues() {
        const currentYear = new Date().getFullYear();
        if (sourceYearField && !sourceYearField.value) {
          sourceYearField.value = String(currentYear);
        }
        if (workbookTypeField && !workbookTypeField.value) {
          workbookTypeField.value = 'default';
        }
      }

      setDefaultValues();

      if (!enqueueUrl || !uploadsListUrl) {
        console.error('Upload form is missing required URL data attributes.');
        return;
      }

      function clearFieldErrors() {
        const errorFields = form.querySelectorAll('[data-error-for]');
        errorFields.forEach((field) => {
          field.textContent = '';
          field.hidden = true;
        });
        form.querySelectorAll('.input--error').forEach((input) => {
          input.classList.remove('input--error');
        });
      }

      function setFieldError(fieldId, message) {
        const target = form.querySelector(`[data-error-for="${fieldId}"]`);
        const input = document.getElementById(fieldId);
        if (target) {
          target.textContent = message;
          target.hidden = !message;
        }
        if (input && message) {
          input.classList.add('input--error');
        }
      }

      function resetFeedback() {
        if (errorBox) {
          errorBox.hidden = true;
          errorBox.textContent = '';
        }
        if (statusBox) {
          statusBox.textContent = '';
        }
        clearFieldErrors();
      }

      function hideOverlapPanel() {
        if (!overlapPanel) return;
        overlapPanel.hidden = true;
        overlapSummary.textContent = '';
        if (overlapList) {
          overlapList.innerHTML = '';
        }
      }

      function setSubmitting(isSubmitting) {
        const submitButton = form.querySelector('button[type="submit"]');
        if (submitButton) {
          submitButton.disabled = isSubmitting;
        }
        overlapButtons.forEach((button) => {
          button.disabled = isSubmitting;
        });
      }

      function renderOverlapPanel(overlapDetected) {
        if (!overlapPanel || !overlapSummary || !overlapList) return;
        const overlaps = Array.isArray(overlapDetected?.overlaps)
          ? overlapDetected.overlaps
          : [];

        const summaryText =
          overlapDetected?.summary ||
          (overlaps.length
            ? `Detected ${overlaps.length} overlapping range(s).`
            : 'Detected overlapping time ranges.');

        overlapSummary.textContent = summaryText;
        overlapList.innerHTML = '';

        if (overlaps.length) {
          const list = document.createElement('ul');
          overlaps.forEach((overlap) => {
            const item = document.createElement('li');
            const requestedRange = [overlap.requested_start, overlap.requested_end]
              .filter(Boolean)
              .join(' → ');
            const existingRange = [overlap.existing_start, overlap.existing_end]
              .filter(Boolean)
              .join(' → ');
            item.textContent =
              `${overlap.target_table || 'table'} (${overlap.time_range_column || 'range'}) ` +
              `requested ${requestedRange} overlaps existing ${existingRange}`;
            list.appendChild(item);
          });
          overlapList.appendChild(list);
        }

        overlapPanel.hidden = false;
      }

      async function submitPayload(payload) {
        lastPayload = payload;
        setSubmitting(true);

        try {
          const response = await fetch(enqueueUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });

          const contentType = response.headers.get('content-type');
          const isJson = contentType && contentType.includes('application/json');
          const data = isJson ? await response.json() : null;

          if (response.status === 202 && data && data.job && data.job.job_id) {
            if (statusBox) {
              statusBox.textContent = 'Upload queued! Redirecting to uploads list…';
            }
            const jobId = data.job.job_id;
            const redirectUrl = new URL(uploadsListUrl, window.location.origin);
            redirectUrl.searchParams.set(
              'notice',
              'Upload queued and will begin processing shortly.'
            );
            if (jobId) {
              redirectUrl.searchParams.set('job_id', jobId);
            }
            window.location.assign(redirectUrl.toString());
            return;
          }

          if (response.status === 400 && data) {
            const messages = [data.detail, data.validation_summary].filter(Boolean);
            if (errorBox) {
              errorBox.textContent = messages.join(' — ');
              errorBox.hidden = false;
            }
            if (statusBox) {
              statusBox.textContent = '';
            }
            return;
          }

          if (response.status === 409 && data?.overlap_detected) {
            if (statusBox) {
              statusBox.textContent = 'Overlap detected. Choose how to proceed.';
            }
            renderOverlapPanel(data.overlap_detected);
            return;
          }

          throw new Error('Unexpected response from server');
        } catch (error) {
          if (errorBox) {
            errorBox.textContent = error instanceof Error ? error.message : 'Failed to submit request';
            errorBox.hidden = false;
          }
          if (statusBox) {
            statusBox.textContent = '';
          }
        } finally {
          setSubmitting(false);
        }
      }

      function deriveFileMetadata(file) {
        if (!file) return;
        if (workbookNameField && !workbookNameField.value) {
          workbookNameField.value = file.name;
        }
        if (fileSizeField && !fileSizeField.value && typeof file.size === 'number') {
          fileSizeField.value = file.size;
        }
      }

      workbookFileInput?.addEventListener('change', () => {
        const file = workbookFileInput.files?.[0];
        if (file) {
          deriveFileMetadata(file);
        }
      });

      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        resetFeedback();
        if (conflictResolutionField) {
          conflictResolutionField.value = 'append';
        }
        hideOverlapPanel();

        setSubmitting(true);

        const selectedFile = workbookFileInput?.files?.[0] || null;
        const manualPath = (manualPathField?.value || '').trim();

        let hasError = false;
        if (!selectedFile && !manualPath) {
          setFieldError(
            'manual_workbook_path',
            'Choose a workbook file or provide a workbook path.'
          );
          hasError = true;
        }
        if (sheetField && !sheetField.value.trim()) {
          setFieldError('sheet', 'Sheet is required.');
          hasError = true;
        }
        if (sourceYearField && !sourceYearField.value.trim()) {
          setFieldError('source_year', 'Source year is required.');
          hasError = true;
        }

        if (hasError) {
          setSubmitting(false);
          return;
        }

        if (workbookPathField) {
          workbookPathField.value = '';
        }

        if (selectedFile) {
          if (!uploadUrl) {
            console.error('Upload form is missing the upload URL data attribute.');
            if (statusBox) {
              statusBox.textContent = '';
            }
            setSubmitting(false);
            return;
          }

          if (statusBox) {
            statusBox.textContent = 'Uploading workbook…';
          }

          const uploadFormData = new FormData();
          uploadFormData.append('file', selectedFile);

          try {
            const uploadResponse = await fetch(uploadUrl, {
              method: 'POST',
              body: uploadFormData
            });

            const uploadContentType = uploadResponse.headers.get('content-type');
            const uploadIsJson = uploadContentType && uploadContentType.includes('application/json');
            const uploadData = uploadIsJson ? await uploadResponse.json() : null;

            if (uploadResponse.status !== 201 || !uploadData || !uploadData.stored_path) {
              const detail = uploadData?.detail || 'Failed to stage workbook file.';
              throw new Error(detail);
            }

            if (workbookPathField) {
              workbookPathField.value = uploadData.stored_path;
            }
            if (fileSizeField && !fileSizeField.value) {
              const resolvedSize = uploadData.file_size || selectedFile.size;
              if (resolvedSize) {
                fileSizeField.value = resolvedSize;
              }
            }
            if (workbookNameField && !workbookNameField.value) {
              const resolvedName = uploadData.original_filename || selectedFile.name;
              if (resolvedName) {
                workbookNameField.value = resolvedName;
              }
            }

            deriveFileMetadata(selectedFile);

            if (statusBox) {
              statusBox.textContent = 'Enqueuing upload request…';
            }
          } catch (error) {
            if (errorBox) {
              errorBox.textContent = error instanceof Error ? error.message : 'Failed to upload workbook file.';
              errorBox.hidden = false;
            }
            if (statusBox) {
              statusBox.textContent = '';
            }
            setSubmitting(false);
            return;
          }
        } else if (workbookPathField) {
          workbookPathField.value = manualPath;
          if (statusBox) {
            statusBox.textContent = 'Submitting upload request…';
          }
        }

        const formData = new FormData(form);
        const payload = {};
        for (const [key, value] of formData.entries()) {
          if (key === 'workbook_file' || key === 'manual_workbook_path') {
            continue;
          }
          if (value === '') {
            payload[key] = null;
            continue;
          }
          if (numberFields.has(key)) {
            payload[key] = Number(value);
          } else {
            payload[key] = value;
          }
        }

        try {
          await submitPayload(payload);
        } catch (error) {
          if (errorBox) {
            errorBox.textContent = error instanceof Error ? error.message : 'Failed to submit request';
            errorBox.hidden = false;
          }
          if (statusBox) {
            statusBox.textContent = '';
          }
        }
      });

      overlapButtons.forEach((button) => {
        button.addEventListener('click', async (event) => {
          event.preventDefault();
          const resolution = button.dataset.resolution;
          if (!resolution || !lastPayload) {
            return;
          }

          const payload = {
            ...lastPayload,
            conflict_resolution: resolution
          };
          if (conflictResolutionField) {
            conflictResolutionField.value = resolution;
          }

          if (statusBox) {
            statusBox.textContent = `Resubmitting with ${resolution}…`;
          }
          hideOverlapPanel();
          resetFeedback();
          await submitPayload(payload);
        });
      });
    })();
  </script>
{% endblock %}
